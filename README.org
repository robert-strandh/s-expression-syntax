#+TITLE:    s-expression-syntax README
#+AUTHOR:   Jan Moringen
#+EMAIL:    jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+OPTIONS: toc:t num:nil
#+SEQ_TODO: TODO STARTED | DONE

#+BEGIN_SRC lisp :exports both :results silent
  (ql:quickload :s-expression-syntax)
#+END_SRC

* STARTED Introduction

  The ~s-expression-syntax~ library provides declarative rules for
  parsing the various kinds of s-expression syntax used in Common
  Lisp:

  + Special operators

  + Lambda lists

  + Declarations

  + Type specifiers

  + Standard macros

    + ~cl:loop~

  + Feature expressions

* STARTED Concepts

  Explaining things in more detail requires a little bit of
  terminology:

  + Expression :: A data structure which /conceptually/
       consists of atoms and conses (possibly meant for evaluation in
       which case the expression is a /form/). In contrast to the
       usual definition, expressions processed by this library may be
       represented as arbitrary objects which are interpreted as atoms
       and conses according to rules defined by the client using the
       library. That said, processing expressions using the usual
       interpretation of atoms and conses is of course supported.

  + Syntax Description :: An object which describes the syntax of one
       kind of /expression/. For example, there is a syntax
       description for the special operator ~cl:let~ which describes
       (the infinite set) of well-formed ~let~ /expressions/. Besides
       recognizing well-formed /expressions/ of a certain kind, a
       /syntax description/ also contains descriptions of the /parts/
       that can appear within well-formed /expressions/ of that
       kind. For example, for ~cl:let~, the /parts/ are variable names,
       initial value forms, declarations and body forms.

       More precisely, a /syntax description/ consists of a name, a
       list of /parts/ and a parser which consumes /expressions/
       conforming to the described syntax and produces a parse result.

  + Part :: An object which describes a sub-structure of
       the syntax described by a particular /syntax description/. For
       example, the /syntax description/ for ~cl:let~ has a /part/ for
       declaration /expressions/ contained in ~let~ /expressions/.

       More precisely, a /part/ consists of a name, a cardinality,
       which is either one, zero-or-one, one-or-more or zero-or-more,
       and an evaluation which is roughly "evaluated", "not evaluated"
       or "composed of evaluated and non-evaluated /parts/".

       For example, ~cl:defun~ has the following /parts/

       | Name                 | Cardinality  | Evaluation                                      |
       |----------------------+--------------+-------------------------------------------------|
       | name                 | one          | not evaluated                                   |
       | lambda-list          | one          | composed of evaluated and non-evaluated /parts/ |
       | documentation string | zero-or-one  | not evaluated                                   |
       | declaration          | zero-or-more | not evaluated                                   |
       | body forms           | zero-or-more | evaluated                                       |

* STARTED Tutorial

  #+BEGIN_SRC lisp :exports both :results output
    (let* ((syntax     (s-expression-syntax:find-syntax 'let))
           (form       '(let ((a 1) (b 2))
                          (declare (type integer a))
                          (declare (type integer b))
                          (format t "~S" a)
                          (list a b)))
           (components (s-expression-syntax:parse 'list syntax form)))
      (loop :for (component-name form) :on components :by #'cddr
            :for component = (s-expression-syntax:find-component component-name syntax)
            :do (format t "~16A -> ~16S~%~2@Tcardinality: ~S~%~2@Tevaluation:  ~S~2%"
                        component-name form
                        (s-expression-syntax:cardinality component)
                        (s-expression-syntax:evaluation component))))
  #+END_SRC

  #+RESULTS:
  #+begin_example
  FORMS            -> ((FORMAT T "~S" A) (LIST A B))
    cardinality: *
    evaluation:  T

  DECLARATIONS     -> ((TYPE INTEGER B) (TYPE INTEGER A))
    cardinality: *
    evaluation:  NIL

  VALUES           -> (2 1)
    cardinality: *
    evaluation:  T

  NAMES            -> (B A)
    cardinality: *
    evaluation:  (:BINDING :NAMESPACE VARIABLE :SCOPE :LEXICAL :ORDER :PARALLEL
                  :VALUES VALUES)

  #+end_example

* STARTED Dictionary

  #+BEGIN_SRC lisp :results none :exports none :session "doc"
    #.(progn
        #1=(ql:quickload '(:s-expression-syntax :alexandria :split-sequence))
        '#1#)
    (defun doc (symbol kind)
      (let* ((lambda-list (sb-introspect:function-lambda-list symbol))
             (string      (documentation symbol kind))
             (lines       (split-sequence:split-sequence #\Newline string))
             (trimmed     (mapcar (alexandria:curry #'string-left-trim '(#\Space)) lines)))
        (format nil "~(~A~) ~<~{~A~^ ~}~:@>~2%~{~A~^~%~}"
                symbol (list lambda-list) trimmed)))
  #+END_SRC

** STARTED Syntax Description Protocol

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 's-expression-syntax:find-syntax 'function)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   find-syntax NAME &KEY IF-DOES-NOT-EXIST

   Return the syntax description named NAME, if any.

   IF-DOES-NOT-EXIST controls the behavior in case a syntax description
   named NAME does not exist. The following values are allowed:

   #'ERROR

   Signal an error if a syntax description named NAME does not exist.

   OBJECT

   Return OBJECT if a syntax description named NAME does not exist.
   #+end_example

** STARTED Parser Protocol

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 's-expression-syntax::classify 'function)
   #+END_SRC

   #+RESULTS:
   #+begin_example
   classify CLIENT EXPRESSION

   Classify EXPRESSION, possibly according to specialized behavior of CLIENT.

   Return a syntax description object that roughly reflects the kind of
   EXPRESSION. Note that a precise classification would have to take into
   account aspects beyond the syntax, such as the environment, to, for
   example, distinguish function and macro application or variable
   references and symbol macro applications. It should always be possible
   to find an appropriate syntax description:

   + If EXPRESSION is a special form, this function returns the syntax
   description for the corresponding special operator.

   + If EXPRESSION is an application of a standard macro, this function
   returns the syntax description for that macro.

   + If EXPRESSION a list not covered by the above cases, this function
   returns the syntax description for a generic (that is, function or
   macro) application. Note that this case also covers invalid
   applications such as (1 2 3).

   + If EXPRESSION is a symbol but not a keyword, this function returns a
   syntax description for a variable reference.

   + If EXPRESSION is any object that is not covered by the above cases,
   this function returns a syntax description for a self-evaluating
   object.
   #+end_example

   #+BEGIN_SRC lisp :results value :exports results :session "doc"
     (doc 's-expression-syntax:parse 'function)
   #+END_SRC

   #+RESULTS:
   : parse CLIENT SYNTAX EXPRESSION
   :
   : Parse EXPRESSION according to SYNTAX, possibly specialized behavior of CLIENT.
   :
   : TODO

# Local Variables:
# eval: (require 'ob-lisp)
# End:
