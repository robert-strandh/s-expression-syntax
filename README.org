#+TITLE:    s-expression-syntax README
#+AUTHOR:   Jan Moringen
#+EMAIL:    jmoringe@techfak.uni-bielefeld.de
#+LANGUAGE: en

#+OPTIONS: toc:t num:nil
#+SEQ_TODO: TODO STARTED | DONE

#+BEGIN_SRC lisp :exports both :results silent
  (ql:quickload :s-expression-syntax)
#+END_SRC

* STARTED Introduction

  The ~s-expression-syntax~ library provides declarative rules for
  parsing the various bits of Common Lisp's s-expression syntax:

  + Special operators

  + Lambda lists

  + Declarations

  + Type specifiers

  + Standard macros

    + ~cl:loop~

  + Feature expressions

* STARTED Concepts

  Explaining things in more detail requires a little bit of
  terminology:

  + Expression :: A data structure which /conceptually/
       consists of atoms and conses (possibly meant for evaluation in
       which case the expression is a /form/). In contrast to the
       usual definition, expressions processed by this library may be
       represented as arbitrary objects which are interpreted as atoms
       and conses according to rules defined by the client using the
       library. That said, processing expressions using the usual
       interpretation of atoms and conses is of course supported.

  + Syntax Description :: An object which describes the syntax of one
       kind of /expression/. For example, there is a syntax
       description for the special operator ~cl:let~ which describes
       (the infinite set) of well-formed ~let~ /expressions/. Besides
       recognizing well-formed /expressions/ of a certain kind, a
       /syntax description/ also contains descriptions of the /parts/
       that can appear within well-formed /expressions/ of that
       kind. For example, for ~cl:let~, the /parts/ are variable names,
       initial value forms, declarations and body forms.

       More precisely, a /syntax description/ consists of a name, a
       list of /parts/ and a parser which consumes /expressions/
       conforming to the described syntax and produces a parse result.

  + Part :: An object which describes a sub-structure of
       the syntax described by a particular /syntax description/. For
       example, the /syntax description/ for ~cl:let~ has a /part/ for
       declaration /expressions/ contained in ~let~ /expressions/.

       More precisely, a /part/ consists of a name, a cardinality,
       which is either one, zero-or-one, one-or-more or zero-or-more,
       and an evaluation which is roughly "evaluated", "not evaluated"
       or "composed of evaluated and non-evaluated /parts/".

       For example, ~cl:defun~ has the following /parts/

       | Name                 | Cardinality  | Evaluation                                      |
       |----------------------+--------------+-------------------------------------------------|
       | name                 | one          | not evaluated                                   |
       | lambda-list          | one          | composed of evaluated and non-evaluated /parts/ |
       | documentation string | zero-or-one  | not evaluated                                   |
       | declaration          | zero-or-more | not evaluated                                   |
       | body forms           | zero-or-more | evaluated                                       |

* STARTED Tutorial

  #+BEGIN_SRC lisp :exports both :results output
    (let* ((syntax     (s-expression-syntax:find-syntax 'let))
           (form       '(let ((a 1) (b 2))
                          (declare (type integer a))
                          (declare (type integer b))
                          (format t "~S" a)
                          (list a b)))
           (components (s-expression-syntax:parse 'list syntax form)))
      (loop :for (component-name form) :on components :by #'cddr
            :for component = (s-expression-syntax:find-component component-name syntax)
            :do (format t "~16A -> ~16S~%~2@Tcardinality: ~S~%~2@Tevaluation:  ~S~2%"
                        component-name form
                        (s-expression-syntax:cardinality component)
                        (s-expression-syntax:evaluation component))))
  #+END_SRC

  #+RESULTS:
  #+begin_example
  FORMS            -> ((FORMAT T "~S" A) (LIST A B))
    cardinality: *
    evaluation:  T

  DECLARATIONS     -> ((TYPE INTEGER B) (TYPE INTEGER A))
    cardinality: *
    evaluation:  NIL

  VALUES           -> (2 1)
    cardinality: *
    evaluation:  T

  NAMES            -> (B A)
    cardinality: *
    evaluation:  (:BINDING :NAMESPACE VARIABLE :SCOPE :LEXICAL :ORDER :PARALLEL
                  :VALUES VALUES)

  #+end_example

* TODO Dictionary

# Local Variables:
# eval: (require 'ob-lisp)
# End:
